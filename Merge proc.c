#include	<stdlib.h>#include	<string.h>#include	"Misc.h"#define BUFFER_BYTE_SIZE	100L#define	NIL_POINTER			0L#define	UNFINISHED			0#define	FINISHED			255#define MEMORY_OUT_ALERT_ID	131typedef	char	string[31];typedef string	line[50];extern int		inRefNum1,				inRefNum2,				keys[3][2],				numberOfKey,				len1,				len2;extern string	variables[3];extern SFReply	inReply1,				inReply2;extern Boolean	variableTypes[3];extern line		labelLine1,				labelLine2;int		GetKey(int RefNum, char variable[], line LabelLine, int *length);Boolean	GetTypes(void);void	ExtractKey(int keyNumber, line theLine, char s[]);int		ExtractLine(int RefNum, line theLine, char *flag);int		ExtractLine2(line theLine, Ptr start);Boolean	GetKeyColumns(void);Boolean	CompleteMatch(string key1[], string key2[]);Boolean	CompleteLess(string key1[], string key2[]);Boolean	FetchNextLine(int RefNum,  string key[], int fileNum);int		GetKey(int RefNum, char variable[], line labelLine, int *length){	Ptr		returnPtr,			buffPtr;	long	endOfFile,			readCount;	OSErr	theErr;	int		i,			columnNumber;	theErr = GetEOF(RefNum,&endOfFile);			theErr = SetFPos(RefNum,fsFromStart,NIL_POINTER);	if (endOfFile > BUFFER_BYTE_SIZE)		readCount = BUFFER_BYTE_SIZE;	else		readCount = endOfFile;			buffPtr = NewPtr(readCount);		if (buffPtr == NIL_POINTER) {		Alert(MEMORY_OUT_ALERT_ID,NIL_POINTER);		ExitToShell();	}			theErr = FSRead(RefNum,&readCount,buffPtr);	if (theErr != noErr) {		Alert(132,NIL_POINTER);		DisposPtr(buffPtr);		return;	}		returnPtr = strchr(buffPtr,'\r');	theErr = SetFPos(RefNum,fsFromStart,returnPtr-buffPtr+1);	if (theErr != noErr) {		ParamText("\pHaving trouble setting the read marker","\p","\p","\p");		Alert(132,NIL_POINTER);	}						columnNumber = ExtractLine2(labelLine,buffPtr);	*length = columnNumber;		for (i=0; i<columnNumber; i++)		if (strcmp(labelLine[i],variable) == 0) {			DisposPtr(buffPtr);		 	return (i+1);		}	DisposPtr(buffPtr);	return 0;}Boolean	GetTypes(void){	long	oldfilePos,			endOfFile;	OSErr 	theErr;	line	line1,			line2;	Ptr		buffPtr;	string	temp1,			temp2;	int		i;			theErr = GetFPos(inRefNum1,&oldfilePos);		endOfFile = BUFFER_BYTE_SIZE;		buffPtr = NewPtr(BUFFER_BYTE_SIZE);	if (buffPtr == NIL_POINTER) {		Alert(MEMORY_OUT_ALERT_ID,NIL_POINTER);		ExitToShell();	}		theErr = FSRead(inRefNum1,&endOfFile,buffPtr);	i = ExtractLine2(line1,buffPtr);	theErr = SetFPos(inRefNum1,fsFromStart,oldfilePos);	DisposPtr(buffPtr);		theErr = GetFPos(inRefNum2,&oldfilePos);	endOfFile = BUFFER_BYTE_SIZE;		buffPtr = NewPtr(BUFFER_BYTE_SIZE);	if (buffPtr == NIL_POINTER) {		Alert(MEMORY_OUT_ALERT_ID,NIL_POINTER);		ExitToShell();	}		theErr = FSRead(inRefNum2,&endOfFile,buffPtr);	i = ExtractLine2(line2,buffPtr);	theErr = SetFPos(inRefNum2,fsFromStart,oldfilePos);	DisposPtr(buffPtr);			for (i=0; i<numberOfKey; i++) {		ExtractKey(keys[i][0],line1,temp1);		ExtractKey(keys[i][1],line2,temp2);		if (!(IsNumber(temp1) == IsNumber(temp2))) {			itoa(i+1,temp1);			ParamText("\pKey",CtoPstr(temp1),						"\p are not of the same type in both files","\p");			Alert(132,NIL_POINTER);			return FALSE;		}		else			if (IsNumber(temp1))				variableTypes[i] = FALSE;			else				variableTypes[i] = TRUE;	}	return TRUE;	}	void	ExtractKey(int keyNumber, line theLine, char s[]){/*	strcpy(s,theLine[keyNumber-1]);		*/	memcpy(s,theLine[keyNumber-1],30);}int	ExtractLine(int RefNum, line theLine, char *flag){	long	oldfilePos,			endOfFile,			readCount,			tempCount;	OSErr	theErr;	Ptr		returnPtr,			buffPtr;	int		i,			lineLength;	string	tempString;	theErr = GetEOF(RefNum,&endOfFile);	if (theErr != noErr) {		ParamText("\pCannot get EOF position in ExtractLine","\p","\p","\p");		Alert(132,NIL_POINTER);	}				theErr = GetFPos(RefNum,&oldfilePos);			if (oldfilePos >= (endOfFile-1)) {/*		ParamText("\pThe end of the file has been reached","\p","\p","\p");		Alert(132,NIL_POINTER);		*/		*flag = FINISHED;		return 0;	}		theErr = SetFPos(RefNum,fsFromMark,1L);			readCount = BUFFER_BYTE_SIZE;/*			readCount = endOfFile - oldfilePos - 1;	if (readCount > BUFFER_BYTE_SIZE)		readCount = BUFFER_BYTE_SIZE;*/	buffPtr = NewPtrClear(readCount); 	if (buffPtr == NIL_POINTER) {		Alert(MEMORY_OUT_ALERT_ID,NIL_POINTER);		ExitToShell();	}			theErr = FSRead(RefNum,&readCount,buffPtr);/*	if (theErr == eofErr) {		ParamText("\pCannot read the file into buffer in Extract Line","\p","\p","\p");		Alert(132,NIL_POINTER);			return;		}	*/	returnPtr = strchr(buffPtr,'\r');		lineLength = ExtractLine2(theLine,buffPtr);				theErr = SetFPos(RefNum,fsFromStart,oldfilePos+(returnPtr-buffPtr)+1);		DisposPtr(buffPtr);			return lineLength;	}	int		ExtractLine2(line theLine, Ptr start){	int		counter = 0,			tabCounter = 1,			i;	Ptr		returnChar,			ptrCounter,			beginPointer,			tempPtr;	OSErr	theErr;		for (i=0; i<50; i++)		strcpy(theLine[i],"");		beginPointer = start;	returnChar = strchr(beginPointer,'\r');	for (ptrCounter=beginPointer; ptrCounter<returnChar; ptrCounter++)				if (*ptrCounter == '\t')			tabCounter++;	while (TRUE) {		if (beginPointer > returnChar)			break;		tempPtr = StringEnd(beginPointer);		if (tempPtr == beginPointer)			strcpy(theLine[counter],"");/*			memcpy(theLine[counter],"",30);	*/		else {			i = 0;			for (ptrCounter=beginPointer; ptrCounter<tempPtr; ptrCounter++)				theLine[counter][i++] = *ptrCounter;			theLine[counter][i] = '\0';		}		beginPointer = tempPtr + 1;		counter++;	}	return tabCounter;}Boolean	GetKeyColumns(void){	int		i;	string	tempString;		for (i=0; i<3; i++) {		keys[i][0] = -1;		keys[i][1] = -1;	}	for (i=0; i<numberOfKey; i++) {		keys[i][0] = GetKey(inRefNum1,variables[i],labelLine1,&len1);		if (keys[i][0] == 0) {			itoa(i+1,tempString);			ParamText("\pCannot locate key",CtoPstr(tempString),"\p in file ",															inReply1.fName);			Alert(132,NIL_POINTER);			return FALSE;		}					keys[i][1] = GetKey(inRefNum2,variables[i],labelLine2,&len2);		if (keys[i][1] == 0) {			itoa(i+1,tempString);			ParamText("\pCannot locate key",CtoPstr(tempString),"\p in file ",														inReply2.fName);			Alert(132,NIL_POINTER);			return FALSE;		}	}	return TRUE;	}	Boolean	CompleteMatch(string key1[], string key2[]){	int		i;		for (i=0; i<numberOfKey; i++)		if (strcmp(key1[i],key2[i]) != 0)			return FALSE;	return TRUE;}Boolean	CompleteLess(string key1[], string key2[]){	int		i,			number1,			number2;			for (i=0; i<numberOfKey; i++) {		if (variableTypes[i]) {			if (AlphaLess(key1[i],key2[i]))				return TRUE;			else				if (AlphaLess(key2[i],key1[i]))					return FALSE;		}		else {			number1 = atoi(key1[i]);			number2 = atoi(key2[i]);			if (number1 < number2)				return TRUE;			else				if (number1 > number2)					return FALSE;		}	}	return FALSE;}Boolean	FetchNextLine(int RefNum,  string key[], int fileNum){	long	oldfilePos,			readCount,			endOfFile;	OSErr	theErr;	Ptr		buffPtr;	line	tempLine;	string	tempStrings[3];	int		i;	char	tempFlag;		theErr = GetFPos(RefNum,&oldfilePos);	theErr = GetEOF(RefNum,&endOfFile);		if (oldfilePos >= (endOfFile-1))		return TRUE;			theErr = GetFPos(RefNum,&oldfilePos);	theErr = SetFPos(RefNum,fsFromMark,1L);	readCount = BUFFER_BYTE_SIZE;	buffPtr = NewPtr(readCount);	if (buffPtr == NIL_POINTER) {		Alert(MEMORY_OUT_ALERT_ID,NIL_POINTER);		ExitToShell();	}	theErr = FSRead(RefNum,&readCount,buffPtr);		i = ExtractLine2(tempLine,buffPtr);	DisposPtr(buffPtr);	theErr = SetFPos(RefNum,fsFromStart,oldfilePos);		for (i=0; i<numberOfKey; i++) {		ExtractKey(keys[i][fileNum-1],tempLine,tempStrings[i]);	}				if (CompleteLess(key,tempStrings))		return TRUE;	else		return FALSE;		}									