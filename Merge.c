/***** THIS IS THE FILE *****/#include	<string.h>#include	"Merge proc.h"#include	"Misc.h"#include	"Report.h"#include	"Save.h"#include	"WriteFile.h"#define	BASE_RES_ID			400#define NIL_POINTER			0L#define MOVE_TO_FRONT		(WindowPtr)-1L#define REMOVE_ALL_EVENTS	0#define	UNFINISHED			0#define	FINISHED			255#define SAVE_ALERT_ID		129#define SAVE_YES_BUTTON_ID	1#define SAVE_NO_BUTTON_ID	2#define FILE_OPEN_ALERT		133#define DLOG_KEY_BOX		133#define OK_BUTTON_ID		1#define CANCEL_BUTTON_ID	2#define KEY1_TEXT_ID		6#define KEY2_TEXT_ID		7#define KEY3_TEXT_ID		8#define MERGE_START_DLOG_ID	134#define SAVE_DLOG_ID		136#define SAVE_NOW_BUTTON_ID	1#define SAVE_LATER_BUTTON_ID	2#define	MENU_BAR_ID			128#define MENU_ID				128#define APPLE_MENU_ID		128#define ABOUT_PROGRAM_ID	1#define ABOUT_ALERT_ID		128#define FILE_MENU_ID		129#define NEW_ITEM_ID			1#define SAVE_AS_ITEM_ID		3#define QUIT_ITEM_ID		5#define EDIT_MENU_ID		130#define UNDO_ITEM_ID		1#define CUT_ITEM_ID			3#define COPY_ITEM_ID		4#define PASTE_ITEM_ID		5#define CLEAR_ITEM_ID		6#define PREF_MENU_ID		131#define DUPLICATE_ITEM_ID	1#define COUNTER_ITEM_ID		2#define SHOW_REPORT_ITEM_ID	3#define MULTI_PAIRING_ID	4#define SAVE_FILE_TYPE_MENU	132#define SAVE_EXCEL_ITEM_ID	1#define SAVE_WORD_ITEM_ID	2#define TEMP_FILE_NAME		"\pM E R G E R   T E M P"/***************************//*     General Defines     *//***************************/#define	DRAG_THRESHOLD		30#define MIN_SLEEP			60L#define NIL_MOUSE_CONTROL	0L#define LEAVE_WHERE_IT_IS	FALSE#define WNE_TRAP_NUM		0x60#define UNIMPL_TRAP_NUM		0x9F#define SUSPEND_RESUME_BIT	0x0001#define RESUMING			1#define BUFFER_BYTE_SIZE	2024L#define	VISIBLE				TRUE#define HOPELESSLY_FATAL_ERROR	"\pFatal Error"/***** GLOBAL VARIABLES *****/Boolean			Done,				WNEImplemented,				InBackground,				duplicateFlag = TRUE,				countFlag = FALSE,				displaySummary = TRUE,				fileSaved = TRUE,				canSave = FALSE,				multiPairing = TRUE,				variableTypes[3];				MenuHandle		AppleMenu,				FileMenu,				EditMenu,				PrefMenu,				SaveMenu;				EventRecord		myEvent;SFReply			inReply1,				inReply2;				string			variables[3],				keyStrings1[3],				keyStrings2[3];				int				numberOfKey,				keys[3][2],				saveRefNum,				inRefNum1,				inRefNum2,				vRefNumTemp,				lineCounter = 0,				len1,				len2;				line			line1,				line2,				labelLine1,				labelLine2;				OSType			saveFileType = 'XCEL';				void	Beep(int number);void	DodiskEvt(EventRecord myEvent);	void	ToolBoxInit(void);void	MainLoop(void);void 	MenuBarInit(void);void	HandleEvent(void);void	HandleMouseDown(void);void	AdjustMenus(void);void	DoGetInFiles(void);void	DoMerge(void);void	HandleMenuChoice(long MenuChoice);void	HandleAppleChoice(int theItem);void	HandleFileChoice(int theItem);void	HandlePrefChoice(int theItem);void	HandleSaveFileTypeChoice(int theItem);void	MultiPairing(long oldFilePos1, long oldFilePos2, string keyStrings[]);void	SetupFile(void);main(){	int	i;		ToolBoxInit();	MenuBarInit();	SetupFile();	MainLoop();}void	ToolBoxInit(){	MaxApplZone();	MoreMasters();		InitGraf(&thePort);	InitFonts();	FlushEvents(everyEvent,REMOVE_ALL_EVENTS);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NIL_POINTER);	InitCursor();	}void	SetupFile(){	Str255		volName;	OSErr		theErr;		theErr = GetVol(volName,&vRefNumTemp);	}void	MainLoop(){	Boolean		gotEvent;		AdjustMenus();	DrawMenuBar();		Done = FALSE;	InBackground = FALSE;		WNEImplemented = (NGetTrapAddress(WNE_TRAP_NUM,ToolTrap) != 						NGetTrapAddress(UNIMPL_TRAP_NUM,ToolTrap));								while (Done == FALSE) {		if (WNEImplemented)/*			gotEvent = WaitNextEvent(everyEvent,&myEvent,MIN_SLEEP,cursorRgn);		else {					SystemTask();	*/			gotEvent = GetNextEvent(everyEvent,&myEvent);/*		}		*/		if (gotEvent)		HandleEvent();	}}void	MenuBarInit(){	Handle		menuBar;		menuBar = GetNewMBar(MENU_BAR_ID);	SetMenuBar(menuBar);			AppleMenu = GetMHandle(APPLE_MENU_ID);	AddResMenu(AppleMenu,'DRVR');		FileMenu = GetMHandle(FILE_MENU_ID);	EditMenu = GetMHandle(EDIT_MENU_ID);	PrefMenu = GetMHandle(PREF_MENU_ID);	SaveMenu = GetMenu(SAVE_FILE_TYPE_MENU);	InsertMenu(SaveMenu,-1);				DrawMenuBar();}	void	HandleEvent(){	char	c;	switch (myEvent.what) {		case nullEvent:			break;		case mouseDown:			HandleMouseDown();			break;		case autoKey:		case keyDown:			c = myEvent.message & charCodeMask;			if ((myEvent.modifiers & cmdKey) != 0) {				AdjustMenus();				HandleMenuChoice(MenuKey(c));			}			break;		case updateEvt:/*			DoUpdate((WindowPtr)myEvent.message);		*/			break;		case diskEvt:			DodiskEvt(myEvent);			break;		case activateEvt:/*			DoActivate((WindowPtr)myEvent.message,						((myEvent.modifiers & activeFlag) != 0));		*/			break;		case app4Evt:/*			if ((myEvent.message & SUSPEND_RESUME_BIT) == RESUMING) {				InBackground = (myEvent.message & 0x01) == 0;				DoActivate(FrontWindow(),(!InBackground));			} else				DoIdle();			*/			break;		case keyUp:		case mouseUp:			break;		default:			break;	}}void	HandleMouseDown(){	WindowPtr	window;	short int	thePart;	long int	menuChoice, windSize;		thePart = FindWindow(myEvent.where,&window);	switch (thePart) {		case inMenuBar:			AdjustMenus();			menuChoice = MenuSelect(myEvent.where);			HandleMenuChoice(menuChoice);			break;		case inSysWindow:			SystemClick(&myEvent,window);			break;		case inDrag:			DragWindow(window,myEvent.where,&(screenBits.bounds));			break;		case inGoAway:			break;		case inContent:			break;		default:			break;	}}void	AdjustMenus(){	WindowPtr	window;	 	if (canSave)		EnableItem(FileMenu,SAVE_AS_ITEM_ID);	else		DisableItem(FileMenu,SAVE_AS_ITEM_ID);		DisableItem(EditMenu,0);		CheckItem(PrefMenu,DUPLICATE_ITEM_ID,duplicateFlag);	CheckItem(PrefMenu,COUNTER_ITEM_ID,countFlag);	CheckItem(PrefMenu,SHOW_REPORT_ITEM_ID,displaySummary);	CheckItem(PrefMenu,MULTI_PAIRING_ID,multiPairing);	if (saveFileType == 'XCEL') {		CheckItem(SaveMenu,SAVE_EXCEL_ITEM_ID,TRUE);		CheckItem(SaveMenu,SAVE_WORD_ITEM_ID,FALSE);	}	else {		CheckItem(SaveMenu,SAVE_EXCEL_ITEM_ID,FALSE);		CheckItem(SaveMenu,SAVE_WORD_ITEM_ID,TRUE);	}}void	HandleMenuChoice(menuChoice)	long int	menuChoice;{	int	theMenu;	int	theItem;	if (menuChoice != 0) {		theMenu = HiWord(menuChoice);		theItem = LoWord(menuChoice);		switch (theMenu) {			case APPLE_MENU_ID:				HandleAppleChoice(theItem);				break;			case FILE_MENU_ID:				HandleFileChoice(theItem);				break;			case EDIT_MENU_ID:				break;			case PREF_MENU_ID:				HandlePrefChoice(theItem);					break;			case SAVE_FILE_TYPE_MENU:				HandleSaveFileTypeChoice(theItem);				break;		}		HiliteMenu(0);	}}void	HandleAppleChoice(theItem)	int theItem;{	Str255		accName;	int			accNumber;	short int	itemNumber;		switch (theItem)	{		case ABOUT_PROGRAM_ID:			Alert(ABOUT_ALERT_ID,NIL_POINTER);			break;		default:			GetItem(AppleMenu,theItem,accName);			accNumber = OpenDeskAcc(accName);			break;	} }void	HandleFileChoice(theItem)	int	theItem;	{	int		button;	OSErr	theErr;		switch (theItem) {		case NEW_ITEM_ID:			DoGetInFiles();			break;		case SAVE_AS_ITEM_ID:			DoSaveFile();			break;		case QUIT_ITEM_ID:			if (!fileSaved) {				ParamText("\pSave before quitting?","\p","\p","\p");				button = Alert(SAVE_ALERT_ID,NIL_POINTER);				if (button == SAVE_YES_BUTTON_ID)					DoSaveFile();			}						theErr = FSDelete(TEMP_FILE_NAME,vRefNumTemp);						Done = TRUE;			break;		default:			break;	}}void	HandlePrefChoice(int theItem){	switch (theItem) {		case DUPLICATE_ITEM_ID:			if (duplicateFlag)				duplicateFlag = FALSE;			else				duplicateFlag = TRUE;			break;		case COUNTER_ITEM_ID:			if (countFlag)				countFlag = FALSE;			else				countFlag = TRUE;			break;		case SHOW_REPORT_ITEM_ID:			if (displaySummary)				displaySummary = FALSE;			else				displaySummary = TRUE;			break;		case MULTI_PAIRING_ID:			if (multiPairing)				multiPairing = FALSE;			else				multiPairing = TRUE;			break;		default:			break;	}}void	HandleSaveFileTypeChoice(int theItem){	switch (theItem) {		case SAVE_EXCEL_ITEM_ID:			saveFileType = 'XCEL';			break;		case SAVE_WORD_ITEM_ID:			saveFileType = 'MSWD';			break;		default:			break;	}}void	DodiskEvt(myEvent)	EventRecord		myEvent;{	int		theErr;	Point	myPoint;		if (HiWord(myEvent.message) != noErr) {		SetPt(&myPoint,100,100);		theErr = DIBadMount(myPoint,myEvent.message);	}}void	DoGetInFiles(void){	Point		thePoint;	SFTypeList	theList;	int			numTypes = 1,				theItem,				itemType,				i;	DialogPtr	theDialog;	Str255		tempString1,				tempString2,				tempString3;	Handle		itemHandle;	Rect		tempRect;		if (!fileSaved) {		ParamText("\pSave before performing merging?","\p","\p","\p");		i = Alert(SAVE_ALERT_ID,NIL_POINTER);		if (i == SAVE_YES_BUTTON_ID)			DoSaveFile();		FreeAlert(SAVE_ALERT_ID);	}		theDialog = GetNewDialog(DLOG_KEY_BOX,NIL_POINTER,(WindowPtr)-1L);	ModalDialog(NIL_POINTER,&theItem);			if (theItem == CANCEL_BUTTON_ID) {		DisposDialog(theDialog);		return;	}		GetDItem(theDialog,KEY1_TEXT_ID,&itemType,&itemHandle,&tempRect);	GetIText(itemHandle,tempString1);	GetDItem(theDialog,KEY2_TEXT_ID,&itemType,&itemHandle,&tempRect);	GetIText(itemHandle,tempString2);	GetDItem(theDialog,KEY3_TEXT_ID,&itemType,&itemHandle,&tempRect);	GetIText(itemHandle,tempString3);		if ((tempString1[0] == 0) && (tempString2[0] == 0) && (tempString3[0] == 0)) {		DisposDialog(theDialog);		return;	}		theItem = 0;	if (tempString1[0] > 0)		strcpy(variables[theItem++],PtoCstr(tempString1));	if (tempString2[0] > 0)		strcpy(variables[theItem++],PtoCstr(tempString2));	if (tempString3[0] > 0)		strcpy(variables[theItem++],PtoCstr(tempString3));	numberOfKey = theItem;		DisposDialog(theDialog);			SetPt(&thePoint,		(screenBits.bounds.right-screenBits.bounds.left-348)/2										+screenBits.bounds.left,50);			theList[0] = 'TEXT';	SFGetFile(thePoint,"\p",NIL_POINTER,numTypes,theList,NIL_POINTER,&inReply1);	if (!inReply1.good)		return;			SFGetFile(thePoint,"\p",NIL_POINTER,numTypes,theList,NIL_POINTER,&inReply2);	if (!inReply2.good)		return;			DoMerge();}	void	DoMerge(void){	OSErr		theErr;	int			lineLength1,				lineLength2,				oldLineLength1,				oldLineLength2,				i;	string		tempString;	Boolean		flag1,				flag2;	long		tempCount,				tempCount2,				oldFilePos1,				oldFilePos2;	char		doneFlag1 = UNFINISHED,				doneFlag2 = UNFINISHED,				tempChar,				returnChar = '\r';	DialogPtr	theDialog;	Handle		theHandle;	Rect		theRect;									lineCounter = 0;	theErr = FSOpen(inReply1.fName,inReply1.vRefNum,&inRefNum1);	if (theErr != noErr) {		if (theErr == opWrErr) {			ParamText(inReply1.fName,"\p","\p","\p");			Alert(FILE_OPEN_ALERT,NIL_POINTER);		}		return;	}	theErr = SetFPos(inRefNum1,fsFromLEOF,-1L);	tempCount = 1;	theErr = FSRead(inRefNum1,&tempCount,&tempChar);	if (tempChar != '\r') {/*		SysBeep(1);		*/		theErr = FSWrite(inRefNum1,&tempCount,&returnChar);		}	theErr = SetFPos(inRefNum1,fsFromStart,NIL_POINTER);		theErr = FSOpen(inReply2.fName,inReply1.vRefNum,&inRefNum2);	if (theErr != noErr) {		if (theErr == opWrErr) {			ParamText(inReply2.fName,"\p","\p","\p");			Alert(FILE_OPEN_ALERT,NIL_POINTER);		}		return;	}	theErr = SetFPos(inRefNum2,fsFromLEOF,-1L);	tempCount = 1;	theErr = FSRead(inRefNum2,&tempCount,&tempChar);	if (tempChar != '\r') {/*		SysBeep(1);		SysBeep(1);		*/		theErr = FSWrite(inRefNum2,&tempCount,&returnChar);	}	theErr = SetFPos(inRefNum2,fsFromStart,NIL_POINTER);	if (!GetKeyColumns()) {		theErr = FSClose(inRefNum1);		theErr = FSClose(inRefNum2);		return;	}	if (!GetTypes()) {		theErr = FSClose(inRefNum1);		theErr = FSClose(inRefNum2);		return;	}		fileSaved = FALSE;		theErr = SetFPos(inRefNum1,fsFromMark,-1L);	theErr = SetFPos(inRefNum2,fsFromMark,-1L);	if ((theErr = Create(TEMP_FILE_NAME,vRefNumTemp,saveFileType,'TEXT')) == dupFNErr) {		if ((theErr = FSDelete(TEMP_FILE_NAME,vRefNumTemp)) == fLckdErr) {			theErr = RstFLock(TEMP_FILE_NAME,vRefNumTemp);			theErr = FSDelete(TEMP_FILE_NAME,vRefNumTemp);		}		theErr = Create(TEMP_FILE_NAME,vRefNumTemp,saveFileType,'TEXT');	}		theErr = FSOpen(TEMP_FILE_NAME,vRefNumTemp,&saveRefNum);		theDialog = GetNewDialog(MERGE_START_DLOG_ID,NIL_POINTER,MOVE_TO_FRONT);	GetDItem(theDialog,3,&i,&theHandle,&theRect);		ParamText(inReply1.fName,inReply2.fName,"\p","\p");	DrawDialog(theDialog);	itoa(lineCounter,tempString);	SetIText(theHandle,CtoPstr(tempString));			Delay(tempCount = 60,&tempCount2);		if (duplicateFlag)		WriteLabel(labelLine1,labelLine2,len1,len2);					theErr = GetFPos(inRefNum1,&oldFilePos1);	theErr = GetFPos(inRefNum2,&oldFilePos2);			oldLineLength1 = lineLength1 = ExtractLine(inRefNum1,line1,&doneFlag1);	oldLineLength2 = lineLength2 = ExtractLine(inRefNum2,line2,&doneFlag2);	for (i=0; i<numberOfKey; i++) {		ExtractKey(keys[i][0],line1,keyStrings1[i]);		ExtractKey(keys[i][1],line2,keyStrings2[i]);	}				while ((doneFlag1 == UNFINISHED) && (doneFlag2 == UNFINISHED)) {		if (CompleteMatch(keyStrings1,keyStrings2)) {			if (multiPairing) {				MultiPairing(oldFilePos1,oldFilePos2,keyStrings1);							theErr = GetFPos(inRefNum1,&oldFilePos1);			theErr = GetFPos(inRefNum2,&oldFilePos2);						lineLength1 = ExtractLine(inRefNum1,line1,&doneFlag1);			for (i=0; i<numberOfKey; i++)				ExtractKey(keys[i][0],line1,keyStrings1[i]);							lineLength2 = ExtractLine(inRefNum2,line2,&doneFlag2);			for (i=0; i<numberOfKey; i++)				ExtractKey(keys[i][1],line2,keyStrings2[i]);				}			else {				++lineCounter;					WriteMatch(line1,line2,lineLength1,lineLength2);						flag1 = FetchNextLine(inRefNum2,keyStrings1,2);				flag2 = FetchNextLine(inRefNum1,keyStrings2,1);							/*				if ((doneFlag1 == UNFINISHED) && flag1) {	*/				if (flag1) {					lineLength1 = ExtractLine(inRefNum1,line1,&doneFlag1);					for (i=0; i<numberOfKey; i++)						ExtractKey(keys[i][0],line1,keyStrings1[i]);				}		/*				if ((doneFlag2 == UNFINISHED) && flag2) {	*/				if (flag2) {					lineLength2 = ExtractLine(inRefNum2,line2,&doneFlag2);					for (i=0; i<numberOfKey; i++)										ExtractKey(keys[i][1],line2,keyStrings2[i]);				}			}		}		else {				if (CompleteLess(keyStrings1,keyStrings2)) {				++lineCounter;				WriteOne(line1,lineLength1,lineLength2);									if (doneFlag1 == UNFINISHED) {					theErr = GetFPos(inRefNum1,&oldFilePos1);					lineLength1 = ExtractLine(inRefNum1,line1,&doneFlag1);					for (i=0; i<numberOfKey; i++)												ExtractKey(keys[i][0],line1,keyStrings1[i]);				}			}			else 								if (CompleteLess(keyStrings2,keyStrings1)) {					++lineCounter;					WriteTwo(line2,lineLength1,lineLength2);							if (doneFlag2 == UNFINISHED) {						theErr = GetFPos(inRefNum2,&oldFilePos2);						lineLength2 = ExtractLine(inRefNum2,line2,&doneFlag2);						for (i=0; i<numberOfKey; i++)							ExtractKey(keys[i][1],line2,keyStrings2[i]);					}				}		}				itoa(lineCounter,tempString);		SetIText(theHandle,CtoPstr(tempString));		}	while (doneFlag1 == UNFINISHED) {		itoa(++lineCounter,tempString);		SetIText(theHandle,CtoPstr(tempString));						if (CompleteMatch(keyStrings1,keyStrings2)) {				WriteMatch(line1,line2,lineLength1,oldLineLength2);		}		else {			WriteOne(line1,lineLength1,oldLineLength2);		}		lineLength1 = ExtractLine(inRefNum1,line1,&doneFlag1);		if (lineLength1 != 0)			for (i=0; i<numberOfKey; i++)				ExtractKey(keys[i][0],line1,keyStrings1[i]);	}		while (doneFlag2 == UNFINISHED) {			itoa(++lineCounter,tempString);		SetIText(theHandle,CtoPstr(tempString));				if (CompleteMatch(keyStrings1,keyStrings2)) { 			WriteMatch(line1,line2,oldLineLength1,lineLength2);		}		else {			WriteTwo(line2,oldLineLength1,lineLength2);		}						lineLength2 = ExtractLine(inRefNum2,line2,&doneFlag2);		if (lineLength2 != 0)			for (i=0; i<numberOfKey; i++)				ExtractKey(keys[i][1],line2,keyStrings2[i]);	}	SysBeep(1);	theErr = FSClose(saveRefNum);	if (theErr != noErr) {		return;	}		theErr = FSClose(inRefNum1);	if (theErr != noErr) {		return;	}		theErr = FSClose(inRefNum2);	if (theErr != noErr) {		return;	}	canSave = TRUE;	Delay(tempCount = 120,&tempCount2);	DisposDialog(theDialog);		if (displaySummary)		DoReport();	else {		theDialog = GetNewDialog(SAVE_DLOG_ID,NIL_POINTER,MOVE_TO_FRONT);		ModalDialog(NIL_POINTER,&i);		if (i == SAVE_NOW_BUTTON_ID)			DoSaveFile();		DisposDialog(theDialog);	}}void	MultiPairing(long oldFilePos1, long oldFilePos2, string keyStrings[]){	OSErr 	theErr;	int		i,			lineLength1,			lineLength2;	long	filePos1,			filePos2,			endOfFile1,			endOfFile2;	string	tempStrings[3];	char	flag1,			flag2;			theErr = SetFPos(inRefNum1,fsFromStart,oldFilePos1);	theErr = SetFPos(inRefNum2,fsFromStart,oldFilePos2);	theErr = GetEOF(inRefNum1,&endOfFile1);	theErr = GetEOF(inRefNum2,&endOfFile2);		for (i=0; i<numberOfKey; i++)		strcpy(tempStrings[i],keyStrings[i]);			lineLength1 = ExtractLine(inRefNum1,line1,&flag1);	for (i=0; i<numberOfKey; i++)		ExtractKey(keys[i][0],line1,keyStrings1[i]);			do {		theErr = SetFPos(inRefNum2,fsFromStart,oldFilePos2);		lineLength2 = ExtractLine(inRefNum2,line2,&flag2);		for (i=0; i<numberOfKey; i++)			ExtractKey(keys[i][1],line2,keyStrings2[i]);		theErr = GetFPos(inRefNum2,&filePos2);				do {			++lineCounter;			WriteMatch(line1,line2,lineLength1,lineLength2);			theErr = GetFPos(inRefNum2,&filePos2);			lineLength2 = ExtractLine(inRefNum2,line2,&flag2);			for (i=0; i<numberOfKey; i++)				ExtractKey(keys[i][1],line2,keyStrings2[i]);		} while (CompleteMatch(tempStrings,keyStrings2) && (filePos2 < (endOfFile2-1)));				theErr = GetFPos(inRefNum1,&filePos1);		lineLength1 = ExtractLine(inRefNum1,line1,&flag1);		for (i=0; i<numberOfKey; i++)			ExtractKey(keys[i][0],line1,keyStrings1[i]);	} while (CompleteMatch(tempStrings,keyStrings1) && (filePos1 < (endOfFile1-1)));		theErr = SetFPos(inRefNum1,fsFromStart,filePos1);	theErr = SetFPos(inRefNum2,fsFromStart,filePos2);}